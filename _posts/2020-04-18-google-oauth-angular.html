---
layout: post
title: "Integrating Google authentication with your Angular app"
date: 2020-04-18 18:00:00 +0200
categories: angular oauth
author: Jorge Cifuentes
codeurl: https://github.com/jorgecf/google-oauth-angular
---

<div class="excerpt">
    From the user point of view, the option to log in to a website with a Google account is convenient and
    standardized. The Google OAuth API is the way to implement it and, while the library is developed in plain
    JavaScript,
    it can easily be integrated into your Angular application.
</div>
<!--endexcerpt-->

<div class="article-content">
    <div class="text-content">
        <p>
            When you want to add some kind of authentication system to your Angular-powered web app, Google OAuth comes
            in
            handy because it simplifies all the identity verification process for the developer and makes it a
            one-click well recognized action for your user.
        </p>

        <p>
            The OAuth flow is a simple yet powerful one: the user clicks on a "Sign in with Google" button present at
            your page and is prompted with a form to log into his Google account. When the log-in is done, the form
            window
            closes and gives you back the user data and a signed token. And that's all! You can use it to identify your
            users.
        </p>

        <!-- Grab your keys -->
        <section>
            <div class="inter-title">Grab your keys <a id="grab-your-keys" class="anchor">#</a></div>
            <p>
                First things first, you have to create a project through the Google API
                Console to which all log-ins will be associated. Refer to Google <a
                    href="https://developers.google.com/identity/sign-in/web/sign-in" target="_blank"
                    rel="noreferrer noopener">for
                    the creation steps.</a>

                Once created, under the Credentials options, you need to set up an "OAuth 2.0 Client". This will create
                a
                Client ID (our key) for you.

                <img src="/assets/images/oauth_4.png" alt="client id key" />
            </p>

            <p>
                An explicit authorization has to be added for every URL under which the app is going to be stored. For
                testing
                purposes,
                whitelisting your
                local development site should be sufficient.

                <img src="/assets/images/oauth_5.png" alt="whitelisted origins" />

                With this credentials, now your app is allowed to communicate to Google.
            </p>
        </section>

        <!-- Get your app ready -->
        <section>
            <div class="inter-title">Get your app ready <a id="get-your-app-ready" class="anchor">#</a></div>
            <p>
                The SDK is developed in plain JavaScript, so in order to make our compiler happy, we have to install
                the Typescript types provided by the <a href="https://github.com/DefinitelyTyped/DefinitelyTyped"
                    target="_blank" rel="noopener noreferrer">DefinitelyTyped project</a>. Open up a
                terminal and
                install
                them via npm:
                {% highlight js %}npm install --save @types/gapi.auth2{% endhighlight %}
            </p>

            <p>
                By default, you should have the types loaded, since your TS compiler usually looks for them
                under
                the <span class="monotype">node_modules/@types</span> folder, where this
                particular package is installed. If it's not the case, you can assert
                it filling the types array:

                {% highlight js %}"compilerOptions": {"types": ["gapi.auth2"]}{% endhighlight %}
                <div class="code-caption"><span>tsconfig.json</span></div>
            </p>

            <p>
                And a script tag should be placed at your index. This will load the external code.
                {% highlight html %}{% include_relative /snippets/google-oauth5.txt %}{% endhighlight %}
                <div class="code-caption"><span>index.html</span></div>
            </p>
        </section>

        <!-- Place a button -->
        <section>
            <div class="inter-title">Place a button <a id="place-a-button" class="anchor">#</a></div>
            <p>
                I'm going to use a simple button for the user to log-in. When this button is clicked, a prompt will ask
                the
                user to grant permission to your application. Whether they complete the form or abandon it, we'll catch
                the
                result.

                <img src="/assets/images/oauth_2.png" alt="oauth form" />
            </p>

            <p>
                Create a component:
                {% highlight js %}ng generate component auth-button{% endhighlight %}
            </p>

            <p>
                And give it a click handler:

                {% highlight html %}<button (click)="authenticate()">Authenticate</button>{% endhighlight %}
                <div class="code-caption"><span>auth-button.component.html</span></div>

            </p>

            <p>
                Now, you're ready to add the logic behind it.
            </p>
        </section>

        <!-- Make some promises -->
        <section>
            <div class="inter-title">Make some promises <a id="make-some-promises" class="anchor">#</a></div>
            <p>
                Talking to a server is an inherently asynchronous operation.
            </p>

            <p>
                The gapi relies heavily in callbacks in a way I don't feel really comfortable with, so
                my
                personal approach here is wrapping the functions in Promises so they can be called in a more functional
                way.
            </p>

            <p>
                For the set up, you will have to load the auth2 library and initialize it with your app key. I wrote
                this
                function to be called in a "lazy" way, that means, it's not to be called until authentication happens
                for
                the first time.

                {% highlight ts %}{% include_relative /snippets/google-oauth1.txt %}{% endhighlight %}
                <div class="code-caption"><span>auth-button.component.ts</span></div>
            </p>

            <p>
                The second one is the actual authentication method we previously set as the click handler. We
                await for the prompt result and catch the result with the data or the error.

                {% highlight ts %}{% include_relative /snippets/google-oauth2.txt %}{% endhighlight %}
                <div class="code-caption"><span>auth-button.component.ts</span></div>
            </p>

            <p>
                This would work already, but if you want to keep your user logged in when they come back, you can check
                if
                there's one currently stored on your ngOnInit and use it:

                {% highlight ts %}{% include_relative /snippets/google-oauth3.txt %}{% endhighlight %}
                <div class="code-caption"><span>auth-button.component.ts</span></div>

                {% highlight ts %}{% include_relative /snippets/google-oauth4.txt %}{% endhighlight %}
                <div class="code-caption"><span>auth-button.component.ts</span></div>
            </p>

            <p>
                After that, the local variable user is filled with the user data, including a unique ID, and can be sent
                to your server
                to be stored.
            </p>
        </section>

        <!-- Talk to the server -->
        <section>
            <div class="inter-title">Talk to the server <a id="talk-to-the-server" class="anchor">#</a></div>
            <p>
                Now that you have a way to identify each one of your users uniquely and unequivocally, the
                logical
                step forward is to send this info to your backend. Usually, you'd want to store the unique ID in your
                database system of choice.

            </p>
            <p>
                It's not a secret that sending this ID plainly to your backend would raise a huge security issue: you
                have to consider <strong>everything</strong> that comes from your client <em>insecure by default</em>.
            </p>

            <p>
                When the user logs in to your site through Google OAuth, the api gives you not only the personal data
                for
                the user but a token as well. Simply speaking, this token is generated and signed at Google's side and
                it
                states for
                whom user is valid and to which app, until when is valid amongst some other data. This token is what
                you
                will
                send
                to your server, and its validation is the way to make sure your application does not get compromised.
                Google
                provides <a
                    href="https://developers.google.com/identity/sign-in/web/backend-auth#verify-the-integrity-of-the-id-token"
                    target="_blank" rel="noopener noreferrer">the steps needed to validate one of its tokens.</a>
            </p>

            <p>
                Furthermore, they have already built-in libraries to do the dirty work in some languages. For example,
                for
                .NET a
                <span class="monotype">GoogleJsonWebSignature.ValidateAsync</span> method is provided. If you <a
                    href="https://github.com/googleapis/google-api-dotnet-client/blob/master/Src/Support/Google.Apis.Auth/GoogleJsonWebSignature.cs"
                    target="_blank" rel="noopener noreferrer">inspect the code</a>, you will see how every step is
                implemented.

            </p>
        </section>

        <section>
            <div class="inter-title">Final thoughts <a id="final-thoughts" class="anchor">#</a></div>
            <p>
                I hope you found this little covering interesting.
                You can check the working example <a href="{{page.codeurl}}" target="_blank"
                    rel="noreferrer noopener">in my
                    GitHub.</a>
            </p>
        </section>

    </div>

</div>